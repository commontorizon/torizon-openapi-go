/*
Torizon OTA

 This API is rate limited and will return the following headers for each API call.    - X-RateLimit-Limit - The total number of requests allowed within a time period   - X-RateLimit-Remaining - The total number of requests still allowed until the end of the rate limiting period   - X-RateLimit-Reset - The number of seconds until the limit is fully reset  In addition, if an API client is rate limited, it will receive a HTTP 420 response with the following header:     - Retry-After - The number of seconds to wait until this request is allowed  

API version: 2.0-Beta
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// DeviceMetricsAPIService DeviceMetricsAPI service
type DeviceMetricsAPIService service

type ApiGetDeviceDataDevicesDeviceuuidMetricsRequest struct {
	ctx context.Context
	ApiService *DeviceMetricsAPIService
	deviceUuid string
	from *int64
	to *int64
	metric *[]string
	resolution *int32
}

func (r ApiGetDeviceDataDevicesDeviceuuidMetricsRequest) From(from int64) ApiGetDeviceDataDevicesDeviceuuidMetricsRequest {
	r.from = &from
	return r
}

func (r ApiGetDeviceDataDevicesDeviceuuidMetricsRequest) To(to int64) ApiGetDeviceDataDevicesDeviceuuidMetricsRequest {
	r.to = &to
	return r
}

func (r ApiGetDeviceDataDevicesDeviceuuidMetricsRequest) Metric(metric []string) ApiGetDeviceDataDevicesDeviceuuidMetricsRequest {
	r.metric = &metric
	return r
}

func (r ApiGetDeviceDataDevicesDeviceuuidMetricsRequest) Resolution(resolution int32) ApiGetDeviceDataDevicesDeviceuuidMetricsRequest {
	r.resolution = &resolution
	return r
}

func (r ApiGetDeviceDataDevicesDeviceuuidMetricsRequest) Execute() (*MetricsResponse, *http.Response, error) {
	return r.ApiService.GetDeviceDataDevicesDeviceuuidMetricsExecute(r)
}

/*
GetDeviceDataDevicesDeviceuuidMetrics Get metrics data from a single device


This endpoint will return time-bucketed data as reported by the specified device. You must specify a time interval in 
Unix Epoch milliseconds via the `from` and `to` query parameters.

You can optionally specify one or more metrics in the query parameter (e.g. `metrics=metric1&metrics=metrics2`, etc. 
OR `metrics[]=metric1,metrics2`, etc.). If you do not specify, you will get all metrics available in the repository.

You can also specify a `resolution`. This parameter defaults to 200, with a maximum permitted value of 2000, and 
determines the granularity of the data returned. The data returned will be separated into buckets, with each bucket 
representing the mean value of the data returned during that period.

For example, suppose you have a device reporting its CPU temperature every minute. You request that metric, with a 
resolution of 24 and a time interval that is 1 day long. You will get back 24 data points, each representing a
one-hour slice of time. The value returned for each one-hour slice will be the average of the 60 reported 
measurements that the device sent during that hour.
        

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceUuid
 @return ApiGetDeviceDataDevicesDeviceuuidMetricsRequest
*/
func (a *DeviceMetricsAPIService) GetDeviceDataDevicesDeviceuuidMetrics(ctx context.Context, deviceUuid string) ApiGetDeviceDataDevicesDeviceuuidMetricsRequest {
	return ApiGetDeviceDataDevicesDeviceuuidMetricsRequest{
		ApiService: a,
		ctx: ctx,
		deviceUuid: deviceUuid,
	}
}

// Execute executes the request
//  @return MetricsResponse
func (a *DeviceMetricsAPIService) GetDeviceDataDevicesDeviceuuidMetricsExecute(r ApiGetDeviceDataDevicesDeviceuuidMetricsRequest) (*MetricsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MetricsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceMetricsAPIService.GetDeviceDataDevicesDeviceuuidMetrics")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/device-data/devices/{deviceUuid}/metrics"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceUuid"+"}", url.PathEscape(parameterValueToString(r.deviceUuid, "deviceUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.from == nil {
		return localVarReturnValue, nil, reportError("from is required and must be specified")
	}
	if r.to == nil {
		return localVarReturnValue, nil, reportError("to is required and must be specified")
	}

	if r.metric != nil {
		t := *r.metric
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "metric", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "metric", t, "multi")
		}
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "from", r.from, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "to", r.to, "")
	if r.resolution != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "resolution", r.resolution, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v UpstreamEndpointErrorRepr
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v NotFoundRepr
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 416 {
			var v RangeNotSatisfiableRepr
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDeviceDataFleetsFleetidMetricsRequest struct {
	ctx context.Context
	ApiService *DeviceMetricsAPIService
	fleetId string
	from *int64
	to *int64
	metric *[]string
	resolution *int32
}

func (r ApiGetDeviceDataFleetsFleetidMetricsRequest) From(from int64) ApiGetDeviceDataFleetsFleetidMetricsRequest {
	r.from = &from
	return r
}

func (r ApiGetDeviceDataFleetsFleetidMetricsRequest) To(to int64) ApiGetDeviceDataFleetsFleetidMetricsRequest {
	r.to = &to
	return r
}

func (r ApiGetDeviceDataFleetsFleetidMetricsRequest) Metric(metric []string) ApiGetDeviceDataFleetsFleetidMetricsRequest {
	r.metric = &metric
	return r
}

func (r ApiGetDeviceDataFleetsFleetidMetricsRequest) Resolution(resolution int32) ApiGetDeviceDataFleetsFleetidMetricsRequest {
	r.resolution = &resolution
	return r
}

func (r ApiGetDeviceDataFleetsFleetidMetricsRequest) Execute() (*MetricsResponse, *http.Response, error) {
	return r.ApiService.GetDeviceDataFleetsFleetidMetricsExecute(r)
}

/*
GetDeviceDataFleetsFleetidMetrics Get aggregated metrics data from a fleet of devices


This endpoint will return aggregated time-bucketed data as reported by the devices in the specified fleet. You must 
specify a time interval in Unix Epoch milliseconds via the `from` and `to` query parameters. 

You can also specify a `resolution`. This parameter defaults to 200, with a maximum permitted value of 2000, and 
determines the granularity of the data returned. The data returned will be separated into buckets, with each bucket 
representing the aggregated data from the period. For example, if you specify a one day long time interval with a
resolution of 24, you will get 24 buckets, each representing a one hour slice of the day. If you request a resolution 
of 48, your buckets will be 30 minutes long.

You also must specify one or more metrics as query parameters (e.g. `metrics=metric1&metrics=metrics2`, etc. OR 
`metrics[]=metric1,metrics2`, etc.). For each metric you specify, you will get back four different series of datapoints: 

* `{metric}-count` reports how many devices in the fleet actually reported data during this time interval.
* `{metric}-avg` reports the average value of all reported values for the metric in the period. Note that the average 
is over the number of devices that reported data: devices that didn't report the metric during the interval will not
be reflected in this datapoint.
* `{metric}-max` gives the highest value reported by a device in the specified interval
* `{metric}-min` gives the lowest value reported by a device in the specified interval
        

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fleetId
 @return ApiGetDeviceDataFleetsFleetidMetricsRequest
*/
func (a *DeviceMetricsAPIService) GetDeviceDataFleetsFleetidMetrics(ctx context.Context, fleetId string) ApiGetDeviceDataFleetsFleetidMetricsRequest {
	return ApiGetDeviceDataFleetsFleetidMetricsRequest{
		ApiService: a,
		ctx: ctx,
		fleetId: fleetId,
	}
}

// Execute executes the request
//  @return MetricsResponse
func (a *DeviceMetricsAPIService) GetDeviceDataFleetsFleetidMetricsExecute(r ApiGetDeviceDataFleetsFleetidMetricsRequest) (*MetricsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MetricsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceMetricsAPIService.GetDeviceDataFleetsFleetidMetrics")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/device-data/fleets/{fleetId}/metrics"
	localVarPath = strings.Replace(localVarPath, "{"+"fleetId"+"}", url.PathEscape(parameterValueToString(r.fleetId, "fleetId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.from == nil {
		return localVarReturnValue, nil, reportError("from is required and must be specified")
	}
	if r.to == nil {
		return localVarReturnValue, nil, reportError("to is required and must be specified")
	}

	if r.metric != nil {
		t := *r.metric
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "metric", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "metric", t, "multi")
		}
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "from", r.from, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "to", r.to, "")
	if r.resolution != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "resolution", r.resolution, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v UpstreamEndpointErrorRepr
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 416 {
			var v RangeNotSatisfiableRepr
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDeviceDataMetricNamesRequest struct {
	ctx context.Context
	ApiService *DeviceMetricsAPIService
	from *int64
	to *int64
}

func (r ApiGetDeviceDataMetricNamesRequest) From(from int64) ApiGetDeviceDataMetricNamesRequest {
	r.from = &from
	return r
}

func (r ApiGetDeviceDataMetricNamesRequest) To(to int64) ApiGetDeviceDataMetricNamesRequest {
	r.to = &to
	return r
}

func (r ApiGetDeviceDataMetricNamesRequest) Execute() (*PaginationResultString, *http.Response, error) {
	return r.ApiService.GetDeviceDataMetricNamesExecute(r)
}

/*
GetDeviceDataMetricNames Get the list of metrics available in your repository


Lists the metrics available in your repository.

In the default TorizonCore configuration, devices will report certain default metrics. You can also
add your own metrics, as described in the [TorizonCore documentation](https://developer.toradex.com/torizon/torizon-platform/device-monitoring-in-torizoncore/#customizing-device-metrics-for-torizon-platform).
Calling this endpoint will give you the list of valid metric names for your repository; generally this
will include the default set plus any that you have defined yourself.

You can optionally specify a time interval in Unix Epoch milliseconds via the `from` and `to` query parameters.
This will return the list of metrics reported by devices in your repository during that specific interval.
        

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetDeviceDataMetricNamesRequest
*/
func (a *DeviceMetricsAPIService) GetDeviceDataMetricNames(ctx context.Context) ApiGetDeviceDataMetricNamesRequest {
	return ApiGetDeviceDataMetricNamesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginationResultString
func (a *DeviceMetricsAPIService) GetDeviceDataMetricNamesExecute(r ApiGetDeviceDataMetricNamesRequest) (*PaginationResultString, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginationResultString
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceMetricsAPIService.GetDeviceDataMetricNames")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/device-data/metric-names"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.from != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "from", r.from, "")
	}
	if r.to != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "to", r.to, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v UpstreamEndpointErrorRepr
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v NotFoundRepr
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 416 {
			var v RangeNotSatisfiableRepr
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
